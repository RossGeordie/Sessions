let
    // Replace PreviousStep with the step that has your column "Incidents"
    Source = PreviousStep,

    // Fields you want to keep (exclude "price")
    WantedFields = {"id","name","created_at","updated_at","state","assignee"}, // edit to your needed fields

    // Option: lower-case protection for vendor casing drift
    LowerFlag = true,
    Wanted = if LowerFlag then List.Transform(WantedFields, Text.Lower) else WantedFields,

    // Helper: safe get field from record
    SafeGet = (r as record, f as text) => try Record.FieldOrDefault(r, f, null) otherwise null,

    // Helper: convert any nested value into a list of records
    ValueToRecords = (v as any) as list =>
        let
            safe = try v otherwise null
        in
            if safe = null then
                {}
            else if Value.Is(safe, type table) then
                let t = if LowerFlag then Table.TransformColumnNames(safe, Text.Lower) else safe
                in Table.ToRecords(t)
            else if Value.Is(safe, type record) then
                { if LowerFlag then Record.TransformFields(safe, List.Transform(Record.FieldNames(safe), each {_, (x)=>x, type any}), MissingField.Ignore) else safe }
            else if Value.Is(safe, type list) then
                let isRecList = List.Count(safe) > 0 and List.AllTrue(List.Transform(safe, each Value.Is(_, type record)))
                in if isRecList then safe else {}
            else
                {},

    // Walk each outer row, turn nested value into records and project only Wanted fields
    Rows = Table.ToRecords(Source),
    PerRowProjected =
        List.Transform(
            Rows,
            (r) =>
                let
                    nested = Record.FieldOrDefault(r, "Incidents", null),
                    recs = ValueToRecords(nested),
                    projected = List.Transform(
                        recs,
                        (rec) =>
                            Record.FromList(
                                List.Transform(Wanted, each SafeGet(rec, _)),
                                Wanted
                            )
                    )
                in
                    projected
        ),

    // Flatten list-of-lists into single list and make a table
    AllRecs = List.Combine(PerRowProjected),
    Result = if List.Count(AllRecs) = 0 then Table.FromRecords({}, Wanted) else Table.FromRecords(AllRecs)
in
    Result
